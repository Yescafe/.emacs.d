* Basic
** UI Settings
Do not show the startup screen and tool bar. Make the Emacs GUI window maximized.
#+begin_src emacs-lisp
#+end_src

** Chores
#+begin_src emacs-lisp


  (global-set-key (kbd "S-<f5>") 'restart-emacs)
  (global-set-key (kbd "C-.") 'set-mark-command)



  ;; zero.emacs debugging flag
  (setq zero/*debug-flag* t)

  ;; bind resizing frame window
  (global-set-key (kbd "C-x w m") 'toggle-frame-maximized)
  (global-set-key (kbd "C-x w f") 'toggle-frame-fullscreen)
#+end_src

* Utils
#+begin_src emacs-lisp

#+end_src

* Emacs Client
#+begin_src emacs-lisp
#+end_src

* Package Manager
** Use USTC source
#+begin_src emacs-lisp
#+end_src

** Initialize package
#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
  (unless (bound-and-true-p packge--initialized)
    (package-initialize))
#+end_src

** Fix GNUPG path for Windows
#+begin_src emacs-lisp
#+end_src

** Install use-package
#+begin_src emacs-lisp
#+end_src

* Tools
** Garbage Collector Magic Hack
#+begin_src emacs-lisp
#+end_src

** System PATH
#+begin_src emacs-lisp
#+end_src

** Fonts
#+begin_src emacs-lisp
#+end_src

** Theme
Set colorscheme:
#+begin_src emacs-lisp
#+end_src

** macOS trash bin
#+begin_src emacs-lisp
#+end_src

** Wakatime
#+begin_src emacs-lisp
#+end_src

** Keycast
I will only use =keycast-log-mode= to list recent key bindings I used.
#+begin_src emacs-lisp
#+end_src

** Dash
#+begin_src emacs-lisp

#+end_src

** Ace
A window manager instead of the Emacs featureless one.
#+begin_src emacs-lisp
#+end_src

** Vertico, orderless, marginalia
Instead of ivy/counsel/swiper.
#+begin_src emacs-lisp
  ;; extensions (incomplete)

  ;; https://github.com/minad/vertico#configuration
  ;; A few more useful configurations...
  (use-package emacs
	:ensure t
	:init
	;; Add prompt indicator to `completing-read-multiple'.
	;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
	(defun crm-indicator (args)
	  (cons (format "[CRM%s] %s"
			(replace-regexp-in-string
			 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
			 crm-separator)
			(car args))
		(cdr args)))
	(advice-add #'completing-read-multiple :filter-args #'crm-indicator)

	;; Do not allow the cursor in the minibuffer prompt
	(setq minibuffer-prompt-properties
	  '(read-only t cursor-intangible t face minibuffer-prompt))
	(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

	;; Emacs 28: Hide commands in M-x which do not work in the current mode.
	;; Vertico commands are hidden in normal buffers.
	;; (setq read-extended-command-predicate
	;;       #'command-completion-default-include-p)

	;; Enable recursive minibuffers
	(setq enable-recursive-minibuffers t))

  ;; minibuffer annotations
#+end_src

** Doom Modeline
#+begin_src emacs-lisp
#+end_src

** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
	:ensure t)
  (use-package flycheck-rust
	:ensure t)
#+end_src

** Company
#+begin_src emacs-lisp

#+end_src

** Editing
#+begin_src emacs-lisp
#+end_src

** Which key
#+begin_src emacs-lisp
#+end_src

** LSP
#+begin_src emacs-lisp
  (use-package lsp-mode
	:ensure t
	:commands (lsp lsp-deferred)
	:hook ((lsp-mode . lsp-enable-which-key-integrateion)
	   (prog-mode . (lambda ()
			  (unless (derived-mode-p 'emacs-lisp-mode 'lsp-mode)
				(lsp-deferred)))))
	:init
	(setq lsp-keepspace-alive nil
	  lsp-enable-indentation t
	  lsp-auto-guess-root t
	  lsp-enable-snippet t
	  ;; lsp flycheck
	  lsp-prefer-flymake t
	  ;; completion backend provider
	  lsp-prefer-capf t
	  lsp-completion-provider :capf
	  lsp-idle-delay 0.5
	  read-process-output-max (* 1024 1024)
	  lsp-rust-analyzer-cargo-watch-command "clippy"
	  lsp-eldoc-render-all t
	  lsp-rust-analyzer-server-display-inlay-hints t))

  (use-package lsp-ui
	:ensure t
	:after lsp-mode
	:commands lsp-ui-mode
	:hook ((lsp-mode . lsp-ui-mode))
	:init
	(setq
	 ;; https://github.com/emacs-lsp/lsp-ui
	 lsp-ui-sideline-show-diagnostics t
	 lsp-ui-sideline-show-hover t
	 lsp-ui-sideline-show-code-actions t
	 lsp-ui-sideline-delay 1
	 lsp-ui-peek-always-show t
	 lsp-ui-peek-enable t
	 lsp-ui-doc-enable t
	 lsp-ui-doc-delay 0.5
	 lsp-ui-doc-position 'at-point
	 lsp-ui-imenu-enable t
	 lsp-ui-imenu-kind-posiont 'top
	 lsp-ui-imenu-buffer-postion 'right
	 lsp-ui-imenu-auto-refresh t)
	:config
	(define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
	(define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
	:bind
	(("C-c m" . 'lsp-ui-imenu))
	)

  (use-package lsp-ivy
	  :ensure t
	  :commands lsp-ivy-workspace-symbol
	  :bind
	  (("C-c s" . 'lsp-ivy-workspace-symbol)))

  (use-package lsp-treemacs
	:ensure t
	:commands lsp-treemacs-errors-list
	:init
	(when (display-graphic-p)
	  (treemacs-resize-icons 14))
	:bind
	(("C-c e" . 'lsp-treemacs-errors-list)))

  (setq lsp-auto-guess-root nil)
#+end_src

** Treemacs
Pending. I don't know how to use this now.
#+begin_src emacs-lisp
  (use-package treemacs
    :ensure t
    :bind
    (("C-c t p" . 'treemacs)))
#+end_src

** Consult
An alternative swiper. Use its navigations.
#+begin_src emacs-lisp
#+end_src

** Magit
A nice git plugin.
#+begin_src emacs-lisp
#+end_src

** Apheleia
Code formatter while saving.
#+begin_src emacs-lisp
#+end_src

** Vterm toggle
#+begin_src emacs-lisp
#+end_src

** Projectile
Project manager. Incomplete.
#+begin_src emacs-lisp
#+end_src

** Yasnippet
#+begin_src emacs-lisp
#+end_src

* Modes
** org-mode
*** keymaps
#+begin_src emacs-lisp
  (define-key org-mode-map (kbd "C-c a") 'org-agenda)

  (use-package org-modern
	:ensure t
	:hook ((org-mode . org-modern-mode)
		   (org-agenda-finalize . org-modern-agenda)))

  (add-hook 'org-mode-hook (lambda ()
							 (display-line-numbers-mode -1)))
#+end_src

** dired-mode
Advanced dired-mode.
#+begin_src emacs-lisp
  (use-package all-the-icons
	:ensure t)
  (use-package all-the-icons-dired
	:ensure t
	:init
	(when (and *mac* (check-command-available? "gls"))
	  (setq dired-use-ls-dired t
			insert-directory-program (get-command-path "gls")
			dired-listing-switches "-aBhl --group-directories-first"))
	(setq all-the-icons-dired-monochrome nil)
	(add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

  (add-hook 'dired-mode-hook (lambda ()
							   (display-line-numbers-mode -1)))
#+end_src

* Languages
** Coq
#+begin_src emacs-lisp
  (if (check-command-available? "coqtop")
	  (progn
		(use-package proof-general
		  :ensure t
		  :init
		  (setq proof-splash-seen t)
		  (require 'lsp-mode)
		  (add-to-list 'lsp-language-id-configuration '(coq-mode . "coq"))
		  (setq lsp-warn-no-matched-clients nil)
		  :hook
		  ((coq-mode . undo-tree-mode)
		   (coq-mode . (lambda ()
						 (define-key coq-mode-map (kbd "C-c a") 'coq-Search)
						 (define-key coq-mode-map (kbd "s-<return>") 'proof-goto-point)))))

		(use-package company-coq
		  :ensure t
		  :init (add-hook 'coq-mode-hook #'company-coq-mode)
		  :config
		  (setq company-box-doc-enable nil))

		(zero/debug "found `coqtop`, loaded Coq part" "lang")))
#+end_src

** Haskell
#+begin_src emacs-lisp
  (if (check-command-available? "ghc")
	  (progn
		(use-package haskell-mode
		  :ensure t)

		(use-package lsp-haskell
		  :ensure t
		  :after (lsp-mode)
		  :init
		  (add-hook 'haskell-mode-hook #'lsp)
		  (add-hook 'haskell-literate-mode-hook #'lsp))
  
		(zero/debug "found `ghc`, loaded Haskell part" "lang")))
#+end_src

** Agda
#+begin_src emacs-lisp
  (if (and (check-command-available? "agda") (check-command-available? "agda-mode"))
	  (progn
		(load-file (let ((coding-system-for-read 'utf-8))
					 (shell-command-to-string "agda-mode locate")))
		(add-to-list 'auto-mode-alist '("\\.lagda.md\\'" . agda2-mode))

		(add-hook 'agda2-mode-hook (lambda ()
									 (local-set-key (kbd "C-c SPC") #'agda2-give)))

		(zero/debug "found `agda` and `agda-mode`, loaded Agda part" "lang")))
#+end_src

** Go
#+begin_src emacs-lisp
  (if (check-command-available? "go")
	  (progn
		(use-package go-mode
		  :ensure t
		  :config
		  (add-hook 'go-mode-hook #'lsp)
		  (add-hook 'go-mode-hook
					(lambda ()
					  (setq indent-tabs-mode 1)
					  (setq tab-width 4))))

		(zero/debug "found `go`, loaded Go part" "lang")))
#+end_src

** Rust
#+begin_src emacs-lisp
  (if (check-command-available? "cargo")
	  (progn
		(use-package rustic
		  :ensure t
		  :config
		  (setq rustic-format-on-save t))

		(zero/debug "found `cargo`, loaded Rust part" "lang")))
#+end_src

